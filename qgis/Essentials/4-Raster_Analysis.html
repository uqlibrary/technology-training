<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2026-01-12">

<title>Raster Analysis – UQ Library Training Intensives</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-d58b9a2750f78c4ba5585652ef45bd1c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">UQ Library Training Intensives</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../r/setup.html"> 
<span class="menu-text">R</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../qgis/setup.html"> 
<span class="menu-text">QGIS</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../python/setup.html"> 
<span class="menu-text">Python</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../project/details.html"> 
<span class="menu-text">The Project</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../gallery/project_gallery.html"> 
<span class="menu-text">Project Gallery</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://uqlibrary.github.io/technology-training"> 
<span class="menu-text">UQ Library Technology Training</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#what-are-we-going-to-learn" id="toc-what-are-we-going-to-learn" class="nav-link active" data-scroll-target="#what-are-we-going-to-learn">What are we going to learn?</a></li>
  <li><a href="#what-is-raster-data" id="toc-what-is-raster-data" class="nav-link" data-scroll-target="#what-is-raster-data">What is Raster Data?</a></li>
  <li><a href="#install-the-saga-plugin" id="toc-install-the-saga-plugin" class="nav-link" data-scroll-target="#install-the-saga-plugin">Install the SAGA Plugin</a></li>
  <li><a href="#gather-some-data" id="toc-gather-some-data" class="nav-link" data-scroll-target="#gather-some-data">Gather some data</a></li>
  <li><a href="#merge-the-two-dem-layers" id="toc-merge-the-two-dem-layers" class="nav-link" data-scroll-target="#merge-the-two-dem-layers">Merge the two DEM layers</a></li>
  <li><a href="#reproject-the-dem" id="toc-reproject-the-dem" class="nav-link" data-scroll-target="#reproject-the-dem">Reproject the DEM</a></li>
  <li><a href="#clip-the-dem" id="toc-clip-the-dem" class="nav-link" data-scroll-target="#clip-the-dem">Clip the DEM</a></li>
  <li><a href="#change-the-symbology" id="toc-change-the-symbology" class="nav-link" data-scroll-target="#change-the-symbology">Change the symbology</a></li>
  <li><a href="#add-a-hillshade" id="toc-add-a-hillshade" class="nav-link" data-scroll-target="#add-a-hillshade">Add a hillshade</a></li>
  <li><a href="#create-a-watershed-layer" id="toc-create-a-watershed-layer" class="nav-link" data-scroll-target="#create-a-watershed-layer">Create a watershed layer</a></li>
  <li><a href="#channel-network-and-drainage-basin" id="toc-channel-network-and-drainage-basin" class="nav-link" data-scroll-target="#channel-network-and-drainage-basin">Channel network and drainage basin</a></li>
  <li><a href="#viewshed" id="toc-viewshed" class="nav-link" data-scroll-target="#viewshed">Viewshed</a></li>
  <li><a href="#saving-your-project" id="toc-saving-your-project" class="nav-link" data-scroll-target="#saving-your-project">Saving your project</a></li>
  <li><a href="#feedback" id="toc-feedback" class="nav-link" data-scroll-target="#feedback">Feedback</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Raster Analysis</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 12, 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="what-are-we-going-to-learn" class="level2">
<h2 class="anchored" data-anchor-id="what-are-we-going-to-learn">What are we going to learn?</h2>
<p>In this workshop, we will learn about:</p>
<ul>
<li>DEM</li>
<li>Terrain Analysis</li>
<li>Contours</li>
<li>Georeferencing</li>
</ul>
</section>
<section id="what-is-raster-data" class="level2">
<h2 class="anchored" data-anchor-id="what-is-raster-data">What is Raster Data?</h2>
<p>A Digital Elevation Model (DEM) is a common example of <strong>raster data</strong>, i.e.&nbsp;grid data that contains a value in each cell (a bit like the pixels in a coloured picture).</p>
</section>
<section id="install-the-saga-plugin" class="level2">
<h2 class="anchored" data-anchor-id="install-the-saga-plugin">Install the SAGA Plugin</h2>
<p>We need to install a plugin so we can access certain geoprocessing tools (the built-in SAGA provider has been <a href="https://changelog.qgis.org/en/qgis/version/3.30/#processing-drop-unmainted-saga-provider-from-qgis-">removed in version 3.30</a>). Go to <code>Plugins &gt; Manage and Install Plugins...</code> and <code>Search...</code> for “<strong>SAGA</strong>”. From the list on options choose <strong>Processing Saga NextGen Provider</strong> then in the bottom right, click <code>Install Plugin</code>. You might also need to install SAGA (version 9 or above) on your computer, if not already available.</p>
</section>
<section id="gather-some-data" class="level2">
<h2 class="anchored" data-anchor-id="gather-some-data">Gather some data</h2>
<p>Use the download button to download each file into your project directory. You will need a login for that, which is free but can take a bit of time. You can instead <strong>download the two raster files</strong> as an archive from our GitHub repository <a href="https://github.com/uqlibrary/technology-training-assets/raw/master/QGIS/raster/QGIS_Raster_Data.zip">here</a>.</p>
</section>
<section id="merge-the-two-dem-layers" class="level2">
<h2 class="anchored" data-anchor-id="merge-the-two-dem-layers">Merge the two DEM layers</h2>
<p>If you downloaded the archive, make sure you place it into the project directory so you can find it in “Project Home” and easily <strong>load the raster files</strong>: from the Browser panel, we can go into the data archive and drag and drop each <code>.tif</code> file into the Layers panel.</p>
<p>See the visible line between the two raster tiles? That is because the two separate raster files have different maximum and minimum values, so use different shades for different elevations. We have to <strong>merge</strong> them to make sure they use the same colour scale.</p>
<p>To do that, we use the <code>Raster &gt; Miscellaneous &gt; Merge...</code> tool to create one single layer from them.</p>
<ul>
<li>First, select both DEM layers for the “Input layers”</li>
<li>Make sure the option “Place each input file into a separate band” is off, as we want to end up with one single-band layer</li>
<li>We can save the output on disk instead of only creating a temporary file (for example, name it <code>SRTM_DEM_merged</code> and save it inside your project directory)</li>
<li>Click “Run”</li>
</ul>
<blockquote class="blockquote">
<p>You will need to have GDAL installed for this to work.</p>
</blockquote>
<p>We can now remove the two original raster files.</p>
</section>
<section id="reproject-the-dem" class="level2">
<h2 class="anchored" data-anchor-id="reproject-the-dem">Reproject the DEM</h2>
<p>In the merged layer’s Properties (<code>Right click &gt; Properties... &gt; Source</code>), we can see that the Coordinate Reference System (CRS) in use is <a href="https://epsg.io/4326">EPSG:4326 - WGS 84</a>. It is the one that QGIS detected when opening the file. This Geographic Reference System is good for global data, but if we want to focus on a more precise area around Brisbane/Meanjin, and want our analyses to be accurate, we should reproject the data to a local Projected Reference System (PRS). We will also need a projection that uses Metres, rather than Degrees (as EPSG:4326 does). A good PRS for around Brisbane/Meanjin is “<a href="https://epsg.io/7856">EPSG:7856 - GDA2020 / MGA zone 56</a>”. We can’t change that here, we instead will need to use the <strong>Warp (Reproject)</strong> tool.</p>
<ul>
<li>Use the tool <code>Raster &gt; Projections &gt; Warp (Reproject)</code></li>
<li>use the merged layer as an input</li>
<li>pick “EPSG:7856 - GDA2020 / MGA zone 56” as the Target CRS
<ul>
<li>you may need to click the Select CRS button <img src="https://user-images.githubusercontent.com/67612228/197653760-a9df4671-5852-499c-a085-3d995489599a.png" class="img-fluid" alt="image"></li>
<li>untick No CRS</li>
<li>use the filter to search for “7856”</li>
<li>You should be able to find “EPSG:7856 - GDA2020 / MGA zone 56” under <strong>Predefined Coordinate Reference Systems</strong></li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p>If you want to learn more about the static datum GDA2020 (for “Geocentric Datum of Australia 2020”), an upgrade from the previous, less precise GDA94, head to the <a href="https://www.icsm.gov.au/gda2020">ICSM website</a>.</p>
</blockquote>
</section>
<section id="clip-the-dem" class="level2">
<h2 class="anchored" data-anchor-id="clip-the-dem">Clip the DEM</h2>
<p>We now use <code>Raster &gt; Extraction &gt; Clip Raster by Extent</code> to <strong>focus on a smaller area of interest</strong>.</p>
<p>Make sure the DEM is selected in the Input layer, and set the clip extent with <code>... &gt; Draw on Canvas</code>. We want to select an area that is inland, and contains both some of the D’Aguilar National Park, and a section of the Brisbane river (you can untick the DEM in the Layers panel to reveal the basemap).</p>
<p>If you don’t save to file directly, remember two things:</p>
<ul>
<li><strong>rename</strong> your clipped layer so it is more descriptive than the generic “Clipped (extent)”</li>
<li>you are currently using a temporary, <strong>scratch layer</strong>. It will be discarded if you exit QGIS. It is very useful for temporary intermediate files, but it can be safer to save copies of your intermediate data while you work, just in case! You can right-click on the layer and use <code>Export &gt; Save As..</code></li>
</ul>
</section>
<section id="change-the-symbology" class="level2">
<h2 class="anchored" data-anchor-id="change-the-symbology">Change the symbology</h2>
<p>We can style our DEM with a <strong>terrain colour palette</strong>:</p>
<ul>
<li>double-click on the clipped DEM layer</li>
<li>go to the “Symbology” tab</li>
<li>change the Render type to “Singleband pseudocolor”</li>
<li>by default, it uses the min/max values, which is what we want</li>
<li>we can change the “Color ramp” to something more suitable with the drop-down menu and <code>Create new color ramp... &gt; Catalog: cpt-city &gt; Topography &gt; Elevation</code>, for example.</li>
</ul>
</section>
<section id="add-a-hillshade" class="level2">
<h2 class="anchored" data-anchor-id="add-a-hillshade">Add a hillshade</h2>
<p>Adding a <strong>hillshade</strong> makes your visualisation of elevation more readable and visually pleasing by giving an artificial lighting look to your map.</p>
<ul>
<li>Right-click on the DEM layer and “Duplicate layer”</li>
<li>Rename the duplicated layer “hillshade”</li>
<li>Open the Symbology menu for the hillshade layer</li>
<li>Change the “Render type” to “Hillshade”</li>
<li>The defaults should work well, but you can play with the settings, like the Altitude and the Azimuth</li>
<li>Make sure you apply some transparency to the pseudocolour DEM, and place the hillshade layer underneath (in <code>Properties &gt; Symbology &gt; Transparency</code>)</li>
<li>Down the bottom of the window under <strong>Resampling</strong> change the <code>Zoomed: in</code> and <code>out</code> from “Nearest Neighbour” to “Cubic” (this will remove some of the grid-like patterns you might see in your Hillshade layer otherwise)</li>
</ul>
<p>Let’s link these two together.</p>
<ul>
<li>Hold <code>Ctrl</code> and select both the Hillshade and the DEM layers</li>
<li>Press the <code>Add Group</code> button from the top of the <code>Layers</code> panel</li>
<li>Call it DEM</li>
<li>Make sure the DEM is above the Hillshade within this group</li>
</ul>
<blockquote class="blockquote">
<p>Another method is to use the hillshade tool instead of the symbology: <code>Raster &gt; Analysis &gt; Hillshade...</code>.</p>
</blockquote>
</section>
<section id="create-a-watershed-layer" class="level2">
<h2 class="anchored" data-anchor-id="create-a-watershed-layer">Create a watershed layer</h2>
<p>Using the Strahler tool, we can create a <strong>watershed</strong> raster that shows where water would flow according to the DEM.</p>
<p>Open the Processing Toolbox (cog icon) and try using the SAGA Next Gen tool called “<strong>Strahler order</strong>” using the clipped DEM as an input (a temporary file is fine for now).</p>
<p>Look at the result. It looks like there are few issues with our data. You may get a question mark symbol <img src="https://user-images.githubusercontent.com/67612228/197657028-314f7460-1c2c-4a5c-b447-25b82bea39ee.png" class="img-fluid" alt="image"> next to your data, when hovered over it will say “There is no coordinate reference system set!”. To resolve this, issue, simply left-click on the question mark symbol and assign “EPSG:7856 - GDA2020 / MGA zone 56” as the CRS.</p>
<p>However there is still another issue with our data. A common problem with DEMs is that they have sinks and spikes that will make further analyses more difficult. This will mean the analysis is unable to best find where the water would flow. To resolve this, we need to use another tool to smooth out our raster before using the Strahler order tool.</p>
<p>We can use the “Fill sinks (Wang &amp; Liu)” tool to <strong>fill the sinks</strong> in our clipped DEM.</p>
<ul>
<li>When we do that, we might have to play with the “Minimum slope” value. A value of 0.01 degrees should work well if the layer was reprojected to a suitable Projected Reference System.</li>
<li>As an output, we only need to tick the “Filled DEM” (first one in the list), which we can also save to file. You can however keep the “Watershed Basins” output to check that your minimum slope is high enough.</li>
</ul>
<p>If we <strong>re-run the Strahler order tool</strong> on the filled DEM, we will be able to see more useful data.</p>
<p>We can now colour the layer with “Singleband pseudocolor” to highlight the bigger streams. A palette that goes from white (for low values) to a dark colour (for high values) should work well. You can also set the smaller streams to be transparent to filter them out.</p>
<blockquote class="blockquote">
<p>Another way to filter out the noise of the smaller streams and <strong>highlight the major streams</strong> in the network, we can use the <code>Raster &gt; Raster Calculator</code> tool and use a formula like: <code>"name_of_layer@1" &gt;= 6</code> (the value will depend on how many levels exist in the Strahler layer). We need to save to file to be able to do that (name it “strahler_filtered”, for example). This will assign the value 1 to the cells matching the condition, and 0 to what is under the limit.</p>
</blockquote>
</section>
<section id="channel-network-and-drainage-basin" class="level2">
<h2 class="anchored" data-anchor-id="channel-network-and-drainage-basin">Channel network and drainage basin</h2>
<p>Another analysis we can do is use the “Channel network and drainage basins” tool to calculate the <strong>flow direction, channels and drainage basins</strong>.</p>
<ul>
<li>Make sure you run this tool on the filled DEM.</li>
<li>We might have to change the threshold to a higher one if the output includes too many small basins and channels. As the threshold is related to the Strahler order number, the middle point of your previous Strahler order values is a usually a good default.</li>
</ul>
<p>You might want to play with different threshold values depending on what you’re looking for. If you want to look at the main drainage basins of a region, you need to set the threshold higher. If you want to find all the small channels, you need to set the threshold lower. It’s worth trying a few options to find what works best for your dataset and the story you’re trying to tell.</p>
<p>As an output, we only want to load (and save to file) the two non-optional outputs:</p>
<ul>
<li>Channels</li>
<li>Drainage basins (shapefile) (to differentiate the two “Drainage basins” options, you can check what format it saves the file as)</li>
</ul>
<p>This is an example of <strong>creating vector data from raster data</strong>!</p>
<p>We can now play with the <strong>symbology</strong> for those elements. For example:</p>
<ul>
<li>Try using different colours for each basin, by classifying by ID, or remove the fill (<code>Simple fill &gt; Fill Style &gt; No Brush</code>) so you can see the colours of the elevation colours underneath. You can also make the borders more obvious by changing the width of the stroke.</li>
<li>Change the colour of the channels.
<ul>
<li>Change the symbol from “Single Symbol” to Graduated.</li>
<li>Set the <code>Value</code> to “Order”</li>
<li>Choose an appropriate colour ramp</li>
<li>Change the <code>Mode</code> down the bottom of the window to “Equal Interval”</li>
<li>Click Apply</li>
</ul></li>
<li>You can also further differentiate minor channels from major ones by using a “Data defined override” for the Width value:
<ul>
<li>Click on the bar next to <code>Symbol</code> <img src="https://user-images.githubusercontent.com/67612228/197659925-41753cd0-2fc7-4534-b6ec-7ddc4775d721.png" class="img-fluid" alt="image"></li>
<li>Click on the “Data defined override” icon <img src="https://user-images.githubusercontent.com/67612228/197659891-5474b893-2de3-47a4-95f5-9991b394ecf3.png" class="img-fluid" alt="image"> next to the Width field</li>
<li>Use the “Assistant”</li>
<li>“Source” needs to be the column “ORDER” (which corresponds to the Strahler order)</li>
<li>Click the double-arrow icon to “Fetch value range from layer”</li>
<li>Change the “Size from” and “to” values to suitable values</li>
</ul></li>
</ul>
</section>
<section id="viewshed" class="level2">
<h2 class="anchored" data-anchor-id="viewshed">Viewshed</h2>
<p>If you want to know what can be seen from a certain point in a landscape you can use a DEM to perform a Viewshed Analysis.</p>
<p>Open the Processing Toolbox (cog icon) and search for the GDAL tool called “<strong>Viewshed</strong>”.</p>
<ul>
<li><strong>Input Layer</strong>: Choose your <strong>Reprojected DEM</strong> layer</li>
<li>Click the three dots next to <strong>Observer location</strong> to select a point on the map</li>
<li><strong>Observer height, DEM units</strong>: 1.6 (the average human eye height is around 1.6m, choose a height you think might be appropriate)</li>
<li><strong>Target height, DEM units</strong>: 1 (this means that the points around the observer will be obscured by any surface that is higher than 1m. If you want to know what <em>ground</em> your observer will see, choose something closer to 0)</li>
<li><strong>Maximum distance from observer to compute visibility</strong>: 5000 (5km is the distance you can see on flat ground due to the curvature of the earth, this would change if you were higher up, for which you can find <a href="https://www.omnicalculator.com/physics/distance-to-horizon">calculators and a formula</a>)</li>
</ul>
<p>This will produce a black and white raster showing what can be seen, and what can’t. Go to the Layer <strong>Styling Menu</strong>, and change it to <strong>Singleband Pseudocolor</strong>, change the <strong>Mode</strong> to <strong>Equal Interval</strong>, and set the <strong>Classes</strong> to <strong>2</strong>. Change one of the Colors to transparent to highlight either what can be see, or what cannot.</p>
<p>As an extra feature. You can do the reverse analysis with a Viewshed. That is, you could use this to know what landmarks are visible in a landscape. Set the Observer Height to that of a building or tree in the landscape, and the Target Height to be that of people in the landscape, and you’ll know where it can be seen from.</p>
<p>If you want to get more sophisticated with your Viewshed analyses, there is, of course, a plugin called <strong>Visibility Analysis</strong> which will allow you to use one or multiple points as observers, take in account of the Earth’s curvature, see what vector points can see other vector points, and more.</p>
</section>
<section id="saving-your-project" class="level2">
<h2 class="anchored" data-anchor-id="saving-your-project">Saving your project</h2>
<p>Notice the little icon next to some of your layers? We previously created “temporary scratch layers”. This is useful if you keep processing data and creating new layers that you want to discard afterwards. In our case, we do want to keep the “cities” and “rivers” layers, so we need to save them to a file. If we try to close QGIS with scratch layers loaded, it will give you a warning that they will be lost in the process.</p>
<p>You can click on the scratch layer icon to save the file. In the dialog, we can give the layers a <code>File name</code> (in our project’s home directory) and click OK.</p>
<p>You can save your project with the floppy disk icon, or using <kbd>Ctrl</kbd> + <kbd>S</kbd>, and the project should be visible in a list as soon as you open QGIS again.</p>
</section>
<section id="feedback" class="level2">
<h2 class="anchored" data-anchor-id="feedback">Feedback</h2>
<p>Please visit our website to <a href="https://web.library.uq.edu.au/study-and-learning-support/training-and-workshops/software-training-resources">provide feedback</a> and find upcoming training courses we have on offer.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/uqlibrary\.github\.io\/technology-training-intensives\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>