{
  "hash": "a8a09e2ff30ecf83a760f27f1948fcd7",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nexecute:\n    error: true\ntitle: Building your Python Toolkit\n---\n\nIn this standalone workshop, we take a look at the Python building blocks that you'll want to have in your toolkit. This includes:\n\n- Loops\n- Functions\n- Modules\n- I/O and filesystem (using `os` and `sys`)\n\nWe'll work by procedurally building up a bigger and bigger program, containing all the features we cover. That way you've got them all in context\n\nAlong the way, you'll encounter callouts like these:\n\n:::{.callout-tip collapse=false}\n# New feature\n\nDescription of new feature\n:::\n\nThese crop up every time a new feature or concept is introduced.\n\n## Preparation\n\nBefore we begin, please follow the following instructions\n\n1. Open your preferred IDE (e.g. [Spyder](https://www.anaconda.com/download/success)).\n2. [Download the files](texts.zip) for today's session.\n3. Extract them to an accessible location (you'll work from here).\n\n## Part 0: Refresher\n\nBefore we get into the content for this workshop, let's just have a brief refresher on what Python is and how it works.\n\nPython is a program on your computer, just like any other. When you want to *run* Python code, or a `.py` file, the Python program (e.g. `python.exe`) runs. It takes your code as an input and evaluates it. \n\nPython is *also* the name of the programming language which the Python program interprets. So, we refer to the language as Python, and the executable program which interprets it the **interpreter**.\n\nThe language is similar to other high-level, object-oriented languages like R, MATLAB, Julia, JavaScript etc. It is versatile and reads easily.\n\nThere are various ways to run Python, this workshop assumes you're using an IDE like Spyder. Here, we'll write just one script, containing our program.\n\nIn Python we work with two types of objects: **variables** and **functions**.\n\n### Variables\n\nVariables allow you to store information in a named object. We use the `=` operator to created them, with the syntax\n\n<i>\n```python\n<name> = <value>\n```\n</i>\n\nFor example, the script below creates two objects, `example_number` and `example_string`, by assigning values to both.\n\n::: {#83f80939 .cell execution_count=1}\n``` {.python .cell-code}\nexample_number = 100.5\nexample_string = \"Hello!\"\n```\n:::\n\n\n### Functions\n\nFunctions enable you to run predefined Python code. Functions can be built-in, from a module, or written yourself.\n\nTo call (use) a function, the syntax is\n\n<i>\n```python\n<function>(<input_1>, <input_2>, ...)\n```\n</i>\n\nThe parentheses `()` are essential, even if you don't have any inputs.\n\nFor example, let's use the `round()` function to round our `example_number`:\n\n::: {#298402e9 .cell execution_count=2}\n``` {.python .cell-code}\nround(example_number)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n100\n```\n:::\n:::\n\n\n### Keywords and Modules\n\nFinally, you will encounter a third type of command in Python: keywords. These are special commands which alter your code in a predetermined way, and you can't use them for variable names. You also can't write your own - they're baked into Python itself.\n\nKeywords must always be followed by a space (or a colon in special cases). One example is the `import` command, which loads a module. Modules are collections of Python code that *other* people have written, containing lots of functions, variables and submodules.\n\nFor example, the following code imports the `os` module.\n\n::: {#20b9235a .cell execution_count=3}\n``` {.python .cell-code}\nimport os\n```\n:::\n\n\n## Part 1: Verifying your setup\n\nIn the first part of this workshop, we'll learn to use Python's building blocks by verifying our setup is working. We'll need to use\n\n- The `os` module and functions therein\n- The `print()` function\n- Conditionals `if` and `else`\n- Error handling with `raise`\n\nTo begin, **create a new script called `toolkit.py`**. This should be in the same location as the `/texts/` folder you downloaded.\n\n### Using `os` to check the working directory\n\nWe'll begin by diving into an unusual starting point: the `os` module. Python comes with a built in module called `os` (short for operating system) which allows you to interact with your computer. Let's start by importing it\n\n::: {#e34049c9 .cell execution_count=4}\n``` {.python .cell-code}\nimport os\n```\n:::\n\n\n:::{#os .callout-tip collapse=\"true\"}\n# The `os` module\n\nThe `os` module is a built-in Python module that enables interfacing with the operating system. Some popular uses, which aren't looked at in this workshop, are\n\n- `os.chdir(...)`: Change the current working directory to `...`\n- `os.system(...)`: Send the command `...` to a terminal\n- `os.walk(...)`: Recursively *walk* through the files in `...` (requires looping, see later)\n:::\n\nThis links our Python environment to the `os` module so we can now access code from it. The reason that we're starting *here* is because we can use the `os` module to interact with our computer.\n\nNext, we'll use the `print()` function to send a message to the user:\n\n::: {#dcb950cc .cell execution_count=5}\n``` {.python .cell-code}\nimport os\n\nprint(\"Running the Python Toolkit Program\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning the Python Toolkit Program\n```\n:::\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n# The `print()` function\n\nThe function `print(...)` is a built-in function which sends the message `...` to the console. Note that the *output* of the function is technically `None` (this is different to the console message).\n:::\n\nAs a first application of `os`, we'll use it to print the **current working directory**. This is a location on your computer, considered by the program to be *home* - all files are relative to the current working directory. We'll need this later when we deal with file paths.\n\nYou can access the current working directory with the `getcwd()` function within the `os` module. Because the function lives *inside* the module, we need to use the `.` operator.\n\n::: {#eca30527 .cell execution_count=6}\n``` {.python .cell-code}\nimport os\n\nprint(\"Running the Python Toolkit Program\")\nprint(\"The current working directory is\")\nprint(os.getcwd())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning the Python Toolkit Program\nThe current working directory is\nC:\\Users\\uqcwest5\\OneDrive - The University of Queensland\\Tech Training\\technology-training\\Python\\5-python_toolkit\n```\n:::\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n# The `.` operator\n\nThe `.` operator allows you to access objects that exist *within* other objects. Here, we access the `getcwd()` function which lives *inside* the `os` module.\n\nAll objects in Python have *methods* (functions) and *attributes*  (variables) attached to them, which you use the `.` operator to access.\n:::\n\nWe can simplify this process by using f-strings. Including the letter `f` directly *before* a string's first quotation mark tells Python to execute any code within curly brackets:\n\n::: {#cdc85938 .cell execution_count=7}\n``` {.python .cell-code}\nimport os\n\nprint(\"Running the Python Toolkit Program\")\nprint(f\"The current working directory is {os.getcwd()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning the Python Toolkit Program\nThe current working directory is C:\\Users\\uqcwest5\\OneDrive - The University of Queensland\\Tech Training\\technology-training\\Python\\5-python_toolkit\n```\n:::\n:::\n\n\n:::{.callout-warning}\n# Setting the correct working directory\n\nWhen you work with other files, you'll want to set the working directory. Here, we'll be loading data that we store in the same folder as your Python script, so let's move the working directory there.\n\n1. First, copy your script's file path. On Windows, right click the file and press \"copy as path\".\n2. Next, use the `os.chdir()` function to change the current working directory as follows\n\n```python\nos.chdir(r\"path/to/script.py\")\n```\n\nMake sure you include the `r` before the path. This tells Python it's a *raw* string and won't misinterpret the backslashes.\n:::\n\n:::{#fstrings .callout-tip collapse=\"true\"}\n\n# f-strings\n\nYou can include executed code within strings by prepending them with the letter f. The code needs to be placed within curly brackets *inside* the string, and the output of the code will be directly inserted there.\n\n::: {#4fd8c326 .cell execution_count=8}\n``` {.python .cell-code}\nf\"This is an f-string, showing that 1 + 1 = {1 + 1}\"\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n'This is an f-string, showing that 1 + 1 = 2'\n```\n:::\n:::\n\n\n:::\n\n### Managing folders and paths with conditionals\n\nNow that we've printed a welcome message, let's use another function, to ensure that we've got the folder \"texts\" in our working directory. The function lives in a *submodule* of `os`, called `os.paths`, and the function is `exists()`.\n\n::: {#b495afd2 .cell execution_count=9}\n``` {.python .cell-code}\nimport os\n\nprint(\"Running the Python Toolkit Program\")\nprint(f\"The current working directory is {os.getcwd()}\")\n\n# Check that the folder exists in our working directory\nprint(os.path.exists(\"texts\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning the Python Toolkit Program\nThe current working directory is C:\\Users\\uqcwest5\\OneDrive - The University of Queensland\\Tech Training\\technology-training\\Python\\5-python_toolkit\nTrue\n```\n:::\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n# Submodules\n\nMost big modules, including `os`, contain submodules. These are also accessed via the `.` notation:\n\n<i>\n```python\nmodule.submodule.function()\n```\n</i>\n\nSubmodules could also have submodules:\n\n<i>\n```python\nmodule.submodule.submodule_of_submodule.function()\n```\n</i>\n\nThis helps keep the scope clear. For example, there might be lots of submodules with the function `exists()`, but because we call `os.path.exists()`, we know that this one relates to filepaths.\n:::\n\nWhat should we do if the folder doesn't exist? We should probably stop the program, fix our setup, and then try again. \n\nLet's tell Python to print a message if the folder exists. For this, we need to use **conditionals**.\n\nThe keyword `if` indicates that a block of indented code should only be run **if a condition is `True`**. Because the function `os.path.exists()` returns a `True` or `False`, we can use it as the condition.\n\nLet's set up our conditional and test it by printing a message. We have to be careful with the syntax:\n\n<i>\n```python\nif <condition>:\n    code_to_run_if_True\n\ncode_outside_will_always_run\n```\n</i>\n\nIncluding it in our code, we want to substitute:\n\n- `<condition>` $\\rightarrow$ `os.path.exists(\"texts\")`\n- `code_to_run_if_True` $\\rightarrow$ `print(\"The folder /texts/ exists\")`\n\n::: {#66115355 .cell execution_count=10}\n``` {.python .cell-code}\nimport os\n\nprint(\"Running the Python Toolkit Program\")\nprint(f\"The current working directory is {os.getcwd()}\")\n\n# Check that the folder exists in our working directory\nif os.path.exists(\"texts\"):\n    print(\"The folder /texts/ exists\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning the Python Toolkit Program\nThe current working directory is C:\\Users\\uqcwest5\\OneDrive - The University of Queensland\\Tech Training\\technology-training\\Python\\5-python_toolkit\nThe folder /texts/ exists\n```\n:::\n:::\n\n\nWhat if it doesn't exist? We can use the keyword `else` to catch anything that fails the condition.\n\n::: {#435a565e .cell execution_count=11}\n``` {.python .cell-code}\nimport os\n\nprint(\"Running the Python Toolkit Program\")\nprint(f\"The current working directory is {os.getcwd()}\")\n\n# Check that the folder exists in our working directory\nif os.path.exists(\"texts\"):\n    print(\"The folder /texts/ exists.\")\nelse:\n    print(\"The folder /texts/ does not exist.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning the Python Toolkit Program\nThe current working directory is C:\\Users\\uqcwest5\\OneDrive - The University of Queensland\\Tech Training\\technology-training\\Python\\5-python_toolkit\nThe folder /texts/ exists.\n```\n:::\n:::\n\n\n:::{#conditionals .callout-tip collapse=\"true\"}\n# Conditionals: `if`, `elif` and `else`\n\nThe keywords `if`, `elif`, and `else` together constitute the conditionals that Python supports. These allow you to only run code based on certain conditions.\n\nThe first, `if`, is always required. The syntax is,\n\n1. The `if` keyword\n2. A condition, which must become either `True` or `False`\n3. A colon, `:`\n4. The code to run if the condition is `True`. It must be **indented** if on a new line.\n\n<i>\n```python\nif <condition>:\n    code_to_run_if_True\n\ncode_outside_will_always_run\n```\n</i>\n\nThe keyword `elif` allows you to check an additional condition, **only if the previous condition(s) failed**.\n\n<i>\n```python\nif <condition>:\n    code_to_run_if_True\nelif <condition_2>:\n    code_to_run_if_condition2_True\nelif <condition_3>:\n    code_to_run_if_condition3_True\n\ncode_outside_will_always_run\n```\n</i>\n\nFinally, the keyword `else` catches anything that **failed all conditions**\n\n<i>\n```python\nif <condition>:\n    code_to_run_if_True\nelif <condition_2>:\n    code_to_run_if_condition2_True\nelif <condition_3>:\n    code_to_run_if_condition3_True\nelse:\n    code_to_run_if_all_failed\n\ncode_outside_will_always_run\n```\n</i>\n:::\n\nRealistically, we don't want our program to run unless the setup is correct. This means we should *stop* the program if it can't find the folder.\n\nYou've probably already encountered errors in your code. Now it's your chance to code them in manually. To raise an error, \n\n1. Use the `raise` keyword\n2. Follow with a valid error, e.g. `ValueError()`, `KeyError()` etc.\n3. Place a useful message *inside* the brackets.\n\nIn this case, we should use the `FileNotFoundError()`. Let's replace the `else` section:\n\n::: {#c8a049cd .cell execution_count=12}\n``` {.python .cell-code}\nimport os\n\nprint(\"Running the Python Toolkit Program\")\nprint(f\"The current working directory is {os.getcwd()}\")\n\n# Check that the folder exists in our working directory\nif os.path.exists(\"texts\"):\n    print(\"The folder /texts/ exists.\")\nelse:\n    raise FileNotFoundError(\"Cannot find the folder /texts/.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning the Python Toolkit Program\nThe current working directory is C:\\Users\\uqcwest5\\OneDrive - The University of Queensland\\Tech Training\\technology-training\\Python\\5-python_toolkit\nThe folder /texts/ exists.\n```\n:::\n:::\n\n\n:::{#raise .callout-tip collapse=\"true\"}\n# Raising exceptions with `raise`\n\nThe `raise` keyword allows you to raise exceptions (errors) in Python. These stop the execution and print an error message.\n\nThe syntax is\n\n<i>\n```python\nraise SomeError(\"Appropriate error message\")\n```\n</i>\n\nand there are [lots of built in exceptions](https://docs.python.org/3/library/exceptions.html).\n:::\n\n\n### Activity 1\n\nTo make sure that you've set things up correctly, you should raise an error if **the number of files in the texts folder is not five**.\n\nTo set things up, let's use the `os.listdir()` function to get a list of the files, storing them in a variable.\n\n::: {#d37619fd .cell execution_count=13}\n``` {.python .cell-code}\nimport os\n\nprint(\"Running the Python Toolkit Program\")\nprint(f\"The current working directory is {os.getcwd()}\")\n\n# Check that the folder exists in our working directory\nif os.path.exists(\"texts\"):\n    print(\"The folder /texts/ exists.\")\nelse:\n    raise FileNotFoundError(\"Cannot find the folder /texts/.\")\n\n# Check that there are five files in the folder\nfiles_in_texts = os.listdir(\"texts\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning the Python Toolkit Program\nThe current working directory is C:\\Users\\uqcwest5\\OneDrive - The University of Queensland\\Tech Training\\technology-training\\Python\\5-python_toolkit\nThe folder /texts/ exists.\n```\n:::\n:::\n\n\nFor this activity, you can use the `len()` built-in function to determine the size of `files_in_texts`. Then, use a conditional to raise an error if it's not five.\n\nIn sum,\n\n1. Use `len()` to determine the number of objects in `files_in_texts`\n2. Use an `if` statement to check if this is **not equal to five**. You'll need the `!=` (not equal to) operator.\n3. Use the `raise` keyword to raise an error.\n\n:::{.callout-tip collapse=\"true\"}\n# Logical operators\n\nTo check (in)equalities, you can use logical operators. For example,\n\n::: {#47f98df9 .cell execution_count=14}\n``` {.python .cell-code}\n1 == 1  # Equal to\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#8287d4d6 .cell execution_count=15}\n``` {.python .cell-code}\n1 != 2  # Not equal to\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#9e0e5c8c .cell execution_count=16}\n``` {.python .cell-code}\n2 > 1   # Greater than\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\nTrue\n```\n:::\n:::\n\n\n::: {#f088942c .cell execution_count=17}\n``` {.python .cell-code}\n1 <= 1  # Less than or equal to\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nTrue\n```\n:::\n:::\n\n\n:::\n\n:::{.callout-note collapse=\"true\"}\n# Solution\n\nThe new code is \n\n::: {#8d7bd656 .cell execution_count=18}\n``` {.python .cell-code}\nfiles_in_texts = os.listdir(\"texts\")\n\n# Check that there are five files within texts\nif len(files_in_texts) != 5:\n    raise FileNotFoundError(\"Incorrect number of files in /texts/.\")\n```\n:::\n\n\nNote that this doesn't produce an output message. Generally, if everything is fine, we don't need a message.\n\nThe whole program has now become\n\n::: {#3406d8db .cell execution_count=19}\n``` {.python .cell-code}\nimport os\n\nprint(\"Running the Python Toolkit Program\")\nprint(f\"The current working directory is {os.getcwd()}\")\n\n# Check that the folder exists in our working directory\nif os.path.exists(\"texts\"):\n    print(\"The folder /texts/ exists.\")\nelse:\n    raise FileNotFoundError(\"Cannot find the folder /texts/.\")\n\nfiles_in_texts = os.listdir(\"texts\")\n\n# Check that there are five files within texts\nif len(files_in_texts) != 5:\n    raise FileNotFoundError(\"Incorrect number of files in /texts/.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning the Python Toolkit Program\nThe current working directory is C:\\Users\\uqcwest5\\OneDrive - The University of Queensland\\Tech Training\\technology-training\\Python\\5-python_toolkit\nThe folder /texts/ exists.\n```\n:::\n:::\n\n\n:::\n\n\n## Part 2: Analysing the data\n\nIn the second part of this session, we'll learn to use Python's input/output and looping features to analyse the files within texts. We'll use\n\n- The `open()` function and `with ... as ...` keywords for reading\n- String methods and the `set` variable type to analyse the texts\n- `for` loops to automate the process\n\n:::{.callout-note collapse=\"false\"}\n# Code from Part 1\n\nBefore we begin, ensure that your code looks like this. Continue from the bottom throughout part 2.\n\n::: {#a5d53cf0 .cell execution_count=20}\n``` {.python .cell-code}\nimport os\n\nprint(\"Running the Python Toolkit Program\")\nprint(f\"The current working directory is {os.getcwd()}\")\n\n# Check that the folder exists in our working directory\nif os.path.exists(\"texts\"):\n    print(\"The folder /texts/ exists.\")\nelse:\n    raise FileNotFoundError(\"Cannot find the folder /texts/.\")\n\nfiles_in_texts = os.listdir(\"texts\")\n\n# Check that there are five files within texts\nif len(files_in_texts) != 5:\n    raise FileNotFoundError(\"Incorrect number of files in /texts/.\")\n\n#### Part 2 ####\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning the Python Toolkit Program\nThe current working directory is C:\\Users\\uqcwest5\\OneDrive - The University of Queensland\\Tech Training\\technology-training\\Python\\5-python_toolkit\nThe folder /texts/ exists.\n```\n:::\n:::\n\n\n:::\n\n### Reading and manipulating text files\n\nWe'll start by reading the first file, *Macbeth.txt* into Python. Make sure to include the snippets in part 2 *below* the code from part 1.\n\nTo read a file in Python,\n\n1. Create a `with ... as ...` block to make sure the file connection closes properly\n2. At the first `...`, use the `open(<filepath>, encoding = \"utf-8\")` function to open the file. Use `encoding = \"utf-8\"` because your operating system might not have this as the default.\n3. At the second `...`, use a placeholder variable to store the *file connection*. Something like `file`.\n4. Inside the block (like an `if` statement), use `file.read()` to access its contents and store that in a variable. \n\nWe'll use that final variable to perform our analysis. It is completely disconnected from the actual file.\n\n::: {#b27abfcc .cell execution_count=21}\n``` {.python .cell-code}\n#### Part 2 ####\n\nwith open(\"texts/Macbeth.txt\", encoding = \"utf-8\") as file:\n    contents = file.read()\n```\n:::\n\n\n:::{#file-io .callout-tip collapse=\"true\"}\n# File input/output\n\nReading and writing files in Python takes a few steps. Essentially, Python forms a connection to a file with the `open()` function which automatically closes if we do this inside a `with ... as ...` block. \n\nThe syntax is\n\n<i>\n```python\nwith open(\"path_to_file\", encoding = \"...\") as <placeholder>:\n    code_with_file_connection_open\n\ncode_once_connection_has_closed\n```\n</i>\n\nNote that whatever you put at `<placeholder>` will store the file connection. All files have the method `read()`, which parses the contents. A method is a function that you access with `.`.\n\nTypically, you want to store the contents in a variable, like in our `contents` example, which is disconnected from the actual file.\n\nThe encoding refers to how the file stored text. Generally, you should use `encoding = \"utf-8\"`, because the default is based on your operating system and varies from machine to machine.\n\n:::\n\nNext, let's perform some analysis of the text. Our goal is to compare the **total number of words** with the total **unique** number of words.\n\nFirst, we need to apply a *string method* to separate the words in the text. Methods are functions that all variables of a particular type have access to, and we use them with the dot operator `.`. In this case, the `.split()` method will create a *list* by dividing the string every time there is a whitespace.\n\n::: {#738e863f .cell execution_count=22}\n``` {.python .cell-code}\n#### Part 2 ####\n\nwith open(\"texts/Macbeth.txt\", encoding = \"utf-8\") as file:\n    contents = file.read()\n\nwords = contents.split()\n```\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n# Methods\n\nEvery variable has common methods (functions) and attributes (variables) associated with them, accessible via the `.` operator. For example, all strings have the `.lower()` method which makes them lowercase:\n\n::: {#69db49a7 .cell execution_count=23}\n``` {.python .cell-code}\nexample_string = \"THIS WAS IN CAPS\"\nexample_string.lower()\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n'this was in caps'\n```\n:::\n:::\n\n\nOther variables have their own methods. Numbers have the `.as_integer_ratio()` method, which turns the number into a fraction\n\n::: {#039bce03 .cell execution_count=24}\n``` {.python .cell-code}\nexample_int = 5.5\nexample_int.as_integer_ratio()\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n(11, 2)\n```\n:::\n:::\n\n\nand lists have the `.append()` method, which adds another element to the list\n\n::: {#6ea210d1 .cell execution_count=25}\n``` {.python .cell-code}\nexample_list = [\"a\", \"b\"]\nexample_list.append(\"c\")\nprint(example_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['a', 'b', 'c']\n```\n:::\n:::\n\n\n:::\n\nWe can then use the `len()` function again to determine the total number of words and print a message. We can also use `print()` by itself to make an empty line.\n\n::: {#36688d88 .cell execution_count=26}\n``` {.python .cell-code}\n#### Part 2 ####\n\nwith open(\"texts/Macbeth.txt\", encoding = \"utf-8\") as file:\n    contents = file.read()\n\nwords = contents.split()\nword_count = len(words)\n\nprint()\nprint(f\"There are {word_count} words in Macbeth.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThere are 21428 words in Macbeth.\n```\n:::\n:::\n\n\nTo work out the unique number of words, we can convert our list to a different variable type: the **set**. Sets are like lists, but they **only contain unique values**. \n\nWe can convert a variable to another type by using its type as a function, e.g. `int()`, `str()`, `list()`. Here, we'll need `set()`. Then we can use `len()` again to determine its size.\n\n1. Create a *set* of unique words with `set(words)`\n2. Find the count of unique words with `len()`\n3. Print an additional message\n\n::: {#58c4c25d .cell execution_count=27}\n``` {.python .cell-code}\n#### Part 2 ####\n\nwith open(\"texts/Macbeth.txt\", encoding = \"utf-8\") as file:\n    contents = file.read()\n\nwords = contents.split()\nunique_words = set(words)\n\nword_count = len(words)\nunique_word_count = len(unique_words)\n\nprint()\nprint(f\"There are {word_count} words in Macbeth.\")\nprint(f\"There are {unique_word_count} different words in Macbeth.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThere are 21428 words in Macbeth.\nThere are 6207 different words in Macbeth.\n```\n:::\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n# Containers: `list`, `tuple`, `dict` and `set`\n\nPython has four built-in variables which are 'containters': they store multiple values. \n\n**Lists**\n\nLists simply a collection of Python objects. They are **ordered**, so you can access them by their *index*, and they are **mutable**, so you can change individual elements.\n\nCreate a list with square brackets:\n\n::: {#d5d672d6 .cell execution_count=28}\n``` {.python .cell-code}\nexample_list = [1, \"a\", 5.5]\n\n# Mutable - can change specific elements\n# Ordered - access elements by position\nexample_list[0] = \"first\"\nprint(example_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['first', 'a', 5.5]\n```\n:::\n:::\n\n\n**Tuples**\n\nTuples are like lists, but you can't modify its elements. That makes it **ordered** and **immutable**.\n\nCreate a tuple with parentheses:\n\n::: {#73e412be .cell execution_count=29}\n``` {.python .cell-code}\nexample_tuple = (1, \"a\", 5.5)\n\n# Immutable - attempting to change specific element gives error\nexample_tuple[0] = \"first\"\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg ansi-bold\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg ansi-bold\">TypeError</span>                                 Traceback (most recent call last)\nCell <span class=\"ansi-green-fg ansi-bold\">In[29], line 4</span>\n<span class=\"ansi-green-fg\">      1</span> example_tuple <span style=\"color:rgb(98,98,98)\">=</span> (<span style=\"color:rgb(98,98,98)\">1</span>, <span style=\"color:rgb(175,0,0)\">\"</span><span style=\"color:rgb(175,0,0)\">a</span><span style=\"color:rgb(175,0,0)\">\"</span>, <span style=\"color:rgb(98,98,98)\">5.5</span>)\n<span class=\"ansi-green-fg\">      3</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># Immutable - attempting to change specific element gives error</span>\n<span class=\"ansi-green-fg ansi-bold\">----&gt; 4</span> <span class=\"ansi-yellow-bg\">example_tuple</span><span class=\"ansi-yellow-bg\">[</span><span style=\"color:rgb(98,98,98)\" class=\"ansi-yellow-bg\">0</span><span class=\"ansi-yellow-bg\">]</span> <span style=\"color:rgb(98,98,98)\">=</span> <span style=\"color:rgb(175,0,0)\">\"</span><span style=\"color:rgb(175,0,0)\">first</span><span style=\"color:rgb(175,0,0)\">\"</span>\n\n<span class=\"ansi-red-fg ansi-bold\">TypeError</span>: 'tuple' object does not support item assignment</pre>\n```\n:::\n\n:::\n:::\n\n\n**Dictionaries**\n\nDictionaries are like lists, but they are **unordered**. Instead of using *position* to identify elements, you use *keywords*.\n\nCreate a dictionary with curly brackets and `key: value` pairs:\n\n::: {#66965b5d .cell execution_count=30}\n``` {.python .cell-code}\nexample_dict = {\"a\": 1, \"b\": 2, \"c\": 3}\n\n# Can create new elements in dictionary by 'accessing' them\nexample_dict[\"d\"] = 4\nprint(example_dict)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'a': 1, 'b': 2, 'c': 3, 'd': 4}\n```\n:::\n:::\n\n\n**Sets**\n\nSets are like lists but the elements are **unique**. Duplicates will always be removed. They are also **unordered**, so you can't access individual elements unless you loop through the set.\n\n::: {#06038a2f .cell execution_count=31}\n``` {.python .cell-code}\nexample_set = {\"a\", \"a\", 2, 2, \"c\"}\n\nprint(example_set)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{2, 'c', 'a'}\n```\n:::\n:::\n\n\n:::\n\nFinally, let's determine the ratio of unique words to total words\n\n$$\\text{ratio} = \\frac{\\text{unique words}}{\\text{total words}}$$\n\n::: {#67705bf6 .cell execution_count=32}\n``` {.python .cell-code}\n#### Part 2 ####\n\nwith open(\"texts/Macbeth.txt\", encoding = \"utf-8\") as file:\n    contents = file.read()\n\nwords = contents.split()\nunique_words = set(words)\n\nword_count = len(words)\nunique_word_count = len(unique_words)\nratio = unique_word_count / word_count\n\nprint()\nprint(f\"There are {word_count} words in Macbeth.\")\nprint(f\"There are {unique_word_count} different words in Macbeth.\")\nprint(f\"The unique word ratio is {unique_word_count / word_count}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThere are 21428 words in Macbeth.\nThere are 6207 different words in Macbeth.\nThe unique word ratio is 0.2896677244726526\n```\n:::\n:::\n\n\n### Using loops to automate the process\n\nNow that we've analysed *one* of the texts, let's do the same for all five.\n\nThe brute force approach is to copy the code five times and adjust it.\n\nHowever, we can do one better with a `for` loop. This enables us to repeat a section of code *for* each element in an object.\n\n<i>\n```python\nfor <placeholder> in <object>:\n    code_to_repeat\n\ncode_after_loop\n```\n</i>\n\nWe'll start just by printing out the names of each file. We need the list of file names, which we get from `os.listdir(\"texts\")`. \n\n::: {#c455b393 .cell execution_count=33}\n``` {.python .cell-code}\n#### Part 2 ####\n\nwith open(\"texts/Macbeth.txt\", encoding = \"utf-8\") as file:\n    contents = file.read()\n\nwords = contents.split()\nunique_words = set(words)\n\nword_count = len(words)\nunique_word_count = len(unique_words)\nratio = unique_word_count / word_count\n\nprint()\nprint(f\"There are {word_count} words in Macbeth.\")\nprint(f\"There are {unique_word_count} different words in Macbeth.\")\nprint(f\"The unique word ratio is {unique_word_count / word_count}\")\n\nfiles_in_texts = os.listdir(\"texts\")\n\nfor text_path in files_in_texts:\n    print(text_path)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThere are 21428 words in Macbeth.\nThere are 6207 different words in Macbeth.\nThe unique word ratio is 0.2896677244726526\nMacbeth.txt\nPride_and_Prejudice.txt\nThe_Adventures_of_Huckleberry_Finn.txt\nThe_Count_of_Monte_Cristo.txt\nThe_Great_Gatsby.txt\n```\n:::\n:::\n\n\n:::{#loops .callout-tip collapse=\"true\"}\n# `for` loops\n\nTo iterate through an object, running the same code on each element, Python offers the `for` loop.\n\n<i>\n```python\nfor <placeholder> in <object>:\n    code_to_repeat\n\ncode_after_loop\n```\n</i>\n\nWhatever you name in `<placeholder>` will store an element of the `<object>` for each iteration of the loop. \n\nFor example, the following loop prints each element of `example_list`. Each time the loop runs, `letter` stores one of the list's elements, in order.\n\n::: {#449f201d .cell execution_count=34}\n``` {.python .cell-code}\nexample_list = [\"a\", \"b\", \"c\"]\n\nfor letter in example_list:\n    print(letter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na\nb\nc\n```\n:::\n:::\n\n\nThere are a few important keywords you can use to help with loops.\n\n**`break`**\n\nThe keyword `break` tells Python to finish the loop immediately. This is often used with conditionals. For example,\n\n::: {#7423ab33 .cell execution_count=35}\n``` {.python .cell-code}\nexample_list = [\"a\", \"b\", \"c\"]\n\nfor letter in example_list:\n    if letter == \"b\":\n        break\n    print(letter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na\n```\n:::\n:::\n\n\n**`continue`**\n\nThe keyword `continue` tells Python to skip the rest of the current iteration and start the next. \n\n::: {#57c33efa .cell execution_count=36}\n``` {.python .cell-code}\nexample_list = [\"a\", \"b\", \"c\"]\n\nfor letter in example_list:\n    if letter == \"b\":\n        continue\n    print(letter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na\nc\n```\n:::\n:::\n\n\n:::\n\nWe can use our `for` loop to run the whole analysis on each file.\n\nFirst, let's just place the analysis inside the loop. This will run once for each file, but because we haven't changed the path from `\"texts/Macbeth.txt\"`, it will still read Macbeth each time.\n\n::: {#f6ed433c .cell execution_count=37}\n``` {.python .cell-code}\n#### Part 2 ####\nfiles_in_texts = os.listdir(\"texts\")\n\nfor text_path in files_in_texts:\n    with open(\"texts/Macbeth.txt\", encoding = \"utf-8\") as file:\n        contents = file.read()\n\n    words = contents.split()\n    unique_words = set(words)\n\n    word_count = len(words)\n    unique_word_count = len(unique_words)\n    ratio = unique_word_count / word_count\n\n    print()\n    print(f\"There are {word_count} words in Macbeth.\")\n    print(f\"There are {unique_word_count} different words in Macbeth.\")\n    print(f\"The unique word ratio is {unique_word_count / word_count}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThere are 21428 words in Macbeth.\nThere are 6207 different words in Macbeth.\nThe unique word ratio is 0.2896677244726526\n\nThere are 21428 words in Macbeth.\nThere are 6207 different words in Macbeth.\nThe unique word ratio is 0.2896677244726526\n\nThere are 21428 words in Macbeth.\nThere are 6207 different words in Macbeth.\nThe unique word ratio is 0.2896677244726526\n\nThere are 21428 words in Macbeth.\nThere are 6207 different words in Macbeth.\nThe unique word ratio is 0.2896677244726526\n\nThere are 21428 words in Macbeth.\nThere are 6207 different words in Macbeth.\nThe unique word ratio is 0.2896677244726526\n```\n:::\n:::\n\n\nNotice that the final `files_in_texts = os.listdir(\"texts\")` has been removed because it's superfluous.\n\nNow we can use the `text` variable, which changes on each iteration of the loop, in place of the file path. Specifically, we'll make the change\n\n`\"texts/Macbeth.txt\"` $\\rightarrow$ `f\"texts/{text_path}\"`\n\n::: {#a06a1c86 .cell execution_count=38}\n``` {.python .cell-code}\n#### Part 2 ####\nfiles_in_texts = os.listdir(\"texts\")\n\nfor text_path in files_in_texts:\n    with open(f\"texts/{text_path}\", encoding = \"utf-8\") as file:\n        contents = file.read()\n\n    words = contents.split()\n    unique_words = set(words)\n\n    word_count = len(words)\n    unique_word_count = len(unique_words)\n    ratio = unique_word_count / word_count\n\n    print()\n    print(f\"There are {word_count} words in Macbeth.\")\n    print(f\"There are {unique_word_count} different words in Macbeth.\")\n    print(f\"The unique word ratio is {unique_word_count / word_count}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThere are 21428 words in Macbeth.\nThere are 6207 different words in Macbeth.\nThe unique word ratio is 0.2896677244726526\n\nThere are 130410 words in Macbeth.\nThere are 14702 different words in Macbeth.\nThe unique word ratio is 0.11273675331646346\n\nThere are 114125 words in Macbeth.\nThere are 14307 different words in Macbeth.\nThe unique word ratio is 0.12536254107338446\n\nThere are 464023 words in Macbeth.\nThere are 40030 different words in Macbeth.\nThe unique word ratio is 0.0862672755445312\n\nThere are 51257 words in Macbeth.\nThere are 10206 different words in Macbeth.\nThe unique word ratio is 0.19911426731958562\n```\n:::\n:::\n\n\nIf you look closely, it *has* worked - the numbers are changing each time. We need to update our messages though, to make it dynamic.\n\n::: {#1a9b6482 .cell execution_count=39}\n``` {.python .cell-code}\n#### Part 2 ####\nfiles_in_texts = os.listdir(\"texts\")\n\nfor text_path in files_in_texts:\n    with open(f\"texts/{text_path}\", encoding = \"utf-8\") as file:\n        contents = file.read()\n\n    words = contents.split()\n    unique_words = set(words)\n\n    word_count = len(words)\n    unique_word_count = len(unique_words)\n    ratio = unique_word_count / word_count\n\n    print()\n    print(f\"There are {word_count} words in {text_path}.\")\n    print(f\"There are {unique_word_count} different words in {text_path}.\")\n    print(f\"The unique word ratio is {unique_word_count / word_count}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThere are 21428 words in Macbeth.txt.\nThere are 6207 different words in Macbeth.txt.\nThe unique word ratio is 0.2896677244726526\n\nThere are 130410 words in Pride_and_Prejudice.txt.\nThere are 14702 different words in Pride_and_Prejudice.txt.\nThe unique word ratio is 0.11273675331646346\n\nThere are 114125 words in The_Adventures_of_Huckleberry_Finn.txt.\nThere are 14307 different words in The_Adventures_of_Huckleberry_Finn.txt.\nThe unique word ratio is 0.12536254107338446\n\nThere are 464023 words in The_Count_of_Monte_Cristo.txt.\nThere are 40030 different words in The_Count_of_Monte_Cristo.txt.\nThe unique word ratio is 0.0862672755445312\n\nThere are 51257 words in The_Great_Gatsby.txt.\nThere are 10206 different words in The_Great_Gatsby.txt.\nThe unique word ratio is 0.19911426731958562\n```\n:::\n:::\n\n\nFinally, let's remove the trailing `.txt` on the messages by extracting the text's title from its path. To do this, *slice* the string with square brackets: `title = text_path[:-4]`. In this case, we slice from the start of the path *up to the fourth last character*.\n\n:::{#slicing .callout-tip collapse=\"true\"}\n# Indexing and Slicing\n\n**Indexing**\n\nTo extract a substring from a string (or a subset of a list) use square brackets and specify the *position* of the elements you want. For example, to pick out the first letter in the following string,\n\n::: {#e0b7f933 .cell execution_count=40}\n``` {.python .cell-code}\nexample_string = \"apple\"\n```\n:::\n\n\nyou specify the position of the first element, which is `0` (in Python, count from 0):\n\n::: {#404b7925 .cell execution_count=41}\n``` {.python .cell-code}\nexample_string[0] # First element\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\n'a'\n```\n:::\n:::\n\n\nIf you want the second element, use `1`:\n\n::: {#a978ab03 .cell execution_count=42}\n``` {.python .cell-code}\nexample_string[1] # Second element\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\n'p'\n```\n:::\n:::\n\n\nIf you want to count *from the end*, use negatives:\n\n::: {#30ba28c0 .cell execution_count=43}\n``` {.python .cell-code}\nexample_string[-1] # Last element\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\n'e'\n```\n:::\n:::\n\n\n**Slicing**\n\nWhat if you want multiple elements? You *slice* by specifying the start and end indices between a colon:\n\n::: {#fa89b985 .cell execution_count=44}\n``` {.python .cell-code}\nexample_string[1:3] # Elements 1 and 2\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\n'pp'\n```\n:::\n:::\n\n\nNotice that it *includes* the first index but *excludes* the second.\n\nTo start at the beginning, just leave the first index out:\n\n::: {#ac658217 .cell execution_count=45}\n``` {.python .cell-code}\nexample_string[:3] # Elements 0, 1 and 2\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\n'app'\n```\n:::\n:::\n\n\nTo go to the end, leave the second index out:\n\n::: {#9677f75f .cell execution_count=46}\n``` {.python .cell-code}\nexample_string[2:] # Elements 2, 3, ..., -1\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\n'ple'\n```\n:::\n:::\n\n\nFinally, you can combine negative indexing with slicing. For example, to go *up to the last element*:\n\n::: {#af61547c .cell execution_count=47}\n``` {.python .cell-code}\nexample_string[:-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\n'appl'\n```\n:::\n:::\n\n\nIn sum:\n\n| Code | 0 | 1 | 2 | 3 | 4 |\n| ---: | --- | --- | --- | --- | --- |\n| `example_string` | `\"a\"` | `\"p\"` | `\"p\"` | `\"l\"` | `\"e\"` | \n| `example_string[0]` | `\"a\"` | | | | |\n| `example_string[2]` | | | `\"p\"` | | |\n| `example_string[-1]` | | | | | `\"e\"` |\n| `example_string[1:3]` | | `\"p\"` | `\"p\"` | | | \n| `example_string[:3]` | `\"a\"` | `\"p\"` | `\"p\"` | | | \n| `example_string[2:]` | | | `\"p\"` | `\"l\"` | `\"e\"` |\n| `example_string[:-1]` | `\"a\"` | `\"p\"` | `\"p\"` | `\"l\"` | |\n:::\n\n::: {#88600b53 .cell execution_count=48}\n``` {.python .cell-code}\n#### Part 2 ####\nfiles_in_texts = os.listdir(\"texts\")\n\nfor text_path in files_in_texts:\n    title = text_path[:-4] # <-- extract the title\n\n    with open(f\"texts/{text_path}\", encoding = \"utf-8\") as file:\n        contents = file.read()\n\n    words = contents.split()\n    unique_words = set(words)\n\n    word_count = len(words)\n    unique_word_count = len(unique_words)\n    ratio = unique_word_count / word_count\n\n    print()\n    print(f\"There are {word_count} words in {title}.\") # <-- include in message\n    print(f\"There are {unique_word_count} different words in {title}.\") # <-- include in message\n    print(f\"The unique word ratio is {unique_word_count / word_count}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThere are 21428 words in Macbeth.\nThere are 6207 different words in Macbeth.\nThe unique word ratio is 0.2896677244726526\n\nThere are 130410 words in Pride_and_Prejudice.\nThere are 14702 different words in Pride_and_Prejudice.\nThe unique word ratio is 0.11273675331646346\n\nThere are 114125 words in The_Adventures_of_Huckleberry_Finn.\nThere are 14307 different words in The_Adventures_of_Huckleberry_Finn.\nThe unique word ratio is 0.12536254107338446\n\nThere are 464023 words in The_Count_of_Monte_Cristo.\nThere are 40030 different words in The_Count_of_Monte_Cristo.\nThe unique word ratio is 0.0862672755445312\n\nThere are 51257 words in The_Great_Gatsby.\nThere are 10206 different words in The_Great_Gatsby.\nThe unique word ratio is 0.19911426731958562\n```\n:::\n:::\n\n\n### Activity 2\n\nIf you open one of the files, you'll notice that there is front and end matter which isn't from the original texts. Let's remove them and save the cleaned texts. To do so, we'll need to use two skills:\n\n- Slicing\n- Writing to files\n\n#### Part 1: Clean the texts\nTo remove the front/end matter, notice that the original texts all begin after the string \n\n`*** START OF THE PROJECT GUTENBERG EBOOK` \n\nand end before \n\n`*** END OF THE PROJECT GUTENBERG EBOOK`. \n\nTo clean the text,\n\n1. Use the function `contents.find(...)` to find the index corresponding to the keys,\n\n```python\nstart_index = contents.find(...)\nend_index = contents.find(...)\n```\n\n2. Slice the text between those two indices and save it in a variable.\n\n#### Part 2: Write the strings to files\nWriting strings to a file is similar to reading. We'll start by creating a `with ... as ...` block pointing to the new file path:\n\n```python\nwith open(f\"{title}_clean.txt\", \"w\", encoding = \"utf-8\") as file:\n    ...\n```\n\nThen use `file.write(...)` to write the cleaned string to the *new* file.\n\n:::{.callout-note collapse=\"true\"}\n# Solution\n\nThe following code is a possible solution to the problem.\n\n::: {#e2417b1a .cell execution_count=49}\n``` {.python .cell-code}\n#### Part 2 ####\nfiles_in_texts = os.listdir(\"texts\")\n\nfor text_path in files_in_texts:\n    \n    # ...\n    # ...\n    # ...\n\n    # Remove front/end matter and save clean files\n    start_message = \"*** START OF THE PROJECT GUTENBERG EBOOK\"\n    end_message = \"*** END OF THE PROJECT GUTENBERG EBOOK\"\n\n    start = contents.find(start_message)\n    end = contents.find(end_message)\n\n    clean_text = contents[start:end]\n\n    with open(f\"{title}_clean.txt\", \"w\", encoding = \"utf-8\") as file:\n        file.write(clean_text)\n```\n:::\n\n\n:::\n\n## Part 3 (extension): Making it modular\n\nIn this final (optional) part we take a look making our code modular. In Python, you can do this in two ways:\n\n- Within the script, with **functions**\n- Outside the script, with **modules**.\n\n:::{.callout-note collapse=\"false\"}\n# Code from Parts 1 and 2\n\nBefore beginning, just check that your code is up to date:\n\n::: {#5f351f6e .cell execution_count=50}\n``` {.python .cell-code}\nimport os\n\nprint(\"Running the Python Toolkit Program\")\nprint(f\"The current working directory is {os.getcwd()}\")\n\n# Check that the folder exists in our working directory\nif os.path.exists(\"texts\"):\n    print(\"The folder /texts/ exists.\")\nelse:\n    raise FileNotFoundError(\"Cannot find the folder /texts/.\")\n\nfiles_in_texts = os.listdir(\"texts\")\n\n# Check that there are five files within texts\nif len(files_in_texts) != 5:\n    raise FileNotFoundError(\"Incorrect number of files in /texts/.\")\n\n#### Part 2 ####\nfiles_in_texts = os.listdir(\"texts\")\n\nfor text_path in files_in_texts:\n    \n    title = text_path[:-4]\n\n    with open(f\"texts/{text_path}\", encoding = \"utf-8\") as file:\n        contents = file.read()\n\n    words = contents.split()\n    unique_words = set(words)\n\n    word_count = len(words)\n    unique_word_count = len(unique_words)\n    ratio = unique_word_count / word_count\n\n    print()\n    print(f\"There are {word_count} words in {title}.\")\n    print(f\"There are {unique_word_count} different words in {title}.\")\n    print(f\"The unique word ratio is {unique_word_count / word_count}\")\n\n    # Remove front/end matter and save clean files\n    start_message = \"*** START OF THE PROJECT GUTENBERG EBOOK\"\n    end_message = \"*** END OF THE PROJECT GUTENBERG EBOOK\"\n\n    start = contents.find(start_message) + len(start_message)\n    end = contents.find(end_message)\n\n    clean_text = contents[start:end]\n\n    with open(f\"{title}_clean.txt\", \"w\", encoding = \"utf-8\") as file:\n        file.write(clean_text)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning the Python Toolkit Program\nThe current working directory is C:\\Users\\uqcwest5\\OneDrive - The University of Queensland\\Tech Training\\technology-training\\Python\\5-python_toolkit\nThe folder /texts/ exists.\n\nThere are 21428 words in Macbeth.\nThere are 6207 different words in Macbeth.\nThe unique word ratio is 0.2896677244726526\n\nThere are 130410 words in Pride_and_Prejudice.\nThere are 14702 different words in Pride_and_Prejudice.\nThe unique word ratio is 0.11273675331646346\n\nThere are 114125 words in The_Adventures_of_Huckleberry_Finn.\nThere are 14307 different words in The_Adventures_of_Huckleberry_Finn.\nThe unique word ratio is 0.12536254107338446\n\nThere are 464023 words in The_Count_of_Monte_Cristo.\nThere are 40030 different words in The_Count_of_Monte_Cristo.\nThe unique word ratio is 0.0862672755445312\n\nThere are 51257 words in The_Great_Gatsby.\nThere are 10206 different words in The_Great_Gatsby.\nThe unique word ratio is 0.19911426731958562\n```\n:::\n:::\n\n\n:::\n\n### Modularity *within the script*: functions\n\nWe'll start with functions. Functions are like a *script within a script* - a section of code that runs when you call its name. They come in two parts:\n\n1. The function call, which **runs** the code (e.g. `print()`, `len()`, etc.)\n2. The function definition, which **defines** that code\n\nEvery time we've used a function, like `print(...)`, `len(...)`, etc., we have performed function calls. However, we need to write new definitions to make our *own* functions.\n\nLet's make a new function now, `read_book(...)`, which reads a text file and returns the contents as a string, like we do in the loop\n\nWe'll start by defining our function. Do this at the top of your script, just after the import statements. Functions definitions have the following syntax:\n\n<i>\n```python\ndef <function_name>(<input1>, <input2>, ...):\n    code\n    code\n    code\n    return <output>\n```\n</i>\n\nLet's set it up, without including any code yet, with a single input variable `path`:\n\n::: {#de3cb31c .cell execution_count=51}\n``` {.python .cell-code}\nimport os\n\ndef read_book(path):\n    return \n```\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n# Function signature and inputs\n\nThe function signature, `def <signature>:` forms a key part of the definition. Inside the brackets there are different ways to specify the inputs. \n\n**No inputs**\n\nYour function doesn't have to take any inputs. For example,\n\n<i>\n```python\n# Definition:\ndef no_inputs():\n   ...\n   return <output>\n\n# Call:\nno_inputs()\n```\n\n</i>\n\n**Compulsory inputs**\n\nIf you just give the inputs names they are *compulsory*: all calls must include them\n\n<i>\n```python\n# Definition:\ndef compulsory_inputs(input1, input2):\n   ...\n   return <output>\n\n# Call:\ncompulsory_inputs(a, b)\n```\n</i>\n\n**Default / optional inputs**\n\nYou can specify default values for function inputs, which makes them optional\n\n<i>\n```python\n# Definition:\ndef optional_inputs(input1 = \"apple\", input2 = \"banana\"):\n   ...\n   return <output>\n\n# Call:\noptional_inputs(\"cherry\") # Will interpret as input1 = \"cherry\", input2 = \"banana\"\n```\n</i>\n\n\n**Positional vs Keyword arguments**\n\nFinally, when you call a function, you can either specify the inputs directly or let it assume by position.\n\n```python\ndef example(input1, input2, input3):\n    ...\n    return <output>\n\nexample(\"apple\", \"banana\", \"cherry\") \nexample(\"apple\", \"banana\", input3 = \"cherry\")\nexample(input1 = \"apple\", input2 = \"banana\", input3 = \"cherry\")\nexample(input3 = \"cherry\", input2 = \"banana\", input1 = \"apple\")\n```\n\nThese are all valid calls, with various differences:\n\n1. All positional\n2. `input1` and `input2` are positional, while `input3` is keyword\n3. All keyword\n4. All keyword - the order doesn't matter for keyword arguments!\n\n:::{.callout-warning}\n# Positional arguments before keyword arguments\n\nBecause keyword arguments are unordered, positional arguments must precede them:\n\n<i>\n```python\n# Valid\nexample(\"apple\", input2 = \"banana\", input3 = \"cherry\")\n\n# Invalid - positional argument after keyword argument!\nexample(input1 = \"apple\", \"banana\", \"cherry\")\n```\n</i>\n\n:::\n\n:::\n\nNow, let's include the code that we previously used to read the file and split the words. Note that the variable containing the full file path is `path`, so we should change that accordingly. \n\n::: {#96a3115b .cell execution_count=52}\n``` {.python .cell-code}\nimport os\n\ndef read_book(path):  \n    with open(path, encoding = \"utf-8\") as file:\n        contents = file.read()\n    \n    return contents\n```\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n# Function scope\n\nVariables created within functions are deleted once the function runs, so they can't be accessed by your main code! This is called scope.\n:::\n\nFinally, let's replace code within the loop with a simple *function call* to our new function. All together,\n\n::: {#458fa185 .cell execution_count=53}\n``` {.python .cell-code}\nimport os\n\ndef read_book(path):  \n    with open(path, encoding = \"utf-8\") as file:\n        contents = file.read()\n    \n    return contents\n\nprint(\"Running the Python Toolkit Program\")\nprint(f\"The current working directory is {os.getcwd()}\")\n\n# Check that the folder exists in our working directory\nif os.path.exists(\"texts\"):\n    print(\"The folder /texts/ exists.\")\nelse:\n    raise FileNotFoundError(\"Cannot find the folder /texts/.\")\n\nfiles_in_texts = os.listdir(\"texts\")\n\n# Check that there are five files within texts\nif len(files_in_texts) != 5:\n    raise FileNotFoundError(\"Incorrect number of files in /texts/.\")\n\n#### Part 2 ####\nfor text_path in files_in_texts:\n    title = text_path[:-4]\n\n    contents = read_book(f\"texts/{text_path}\")   # <-- Custom function call\n    words = contents.split()\n\n    unique_words = set(words)\n\n    word_count = len(words)\n    unique_word_count = len(unique_words)\n    ratio = unique_word_count / word_count\n\n    print()\n    print(f\"There are {word_count} words in {title}.\")\n    print(f\"There are {unique_word_count} different words in {title}.\")\n    print(f\"The unique word ratio is {unique_word_count / word_count}\")\n\n    # Remove front/end matter and save clean files\n    start_message = \"*** START OF THE PROJECT GUTENBERG EBOOK\"\n    end_message = \"*** END OF THE PROJECT GUTENBERG EBOOK\"\n\n    start = contents.find(start_message) + len(start_message)\n    end = contents.find(end_message)\n\n    clean_text = contents[start:end]\n\n    with open(f\"{title}_clean.txt\", \"w\", encoding = \"utf-8\") as file:\n        file.write(clean_text)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning the Python Toolkit Program\nThe current working directory is C:\\Users\\uqcwest5\\OneDrive - The University of Queensland\\Tech Training\\technology-training\\Python\\5-python_toolkit\nThe folder /texts/ exists.\n\nThere are 21428 words in Macbeth.\nThere are 6207 different words in Macbeth.\nThe unique word ratio is 0.2896677244726526\n\nThere are 130410 words in Pride_and_Prejudice.\nThere are 14702 different words in Pride_and_Prejudice.\nThe unique word ratio is 0.11273675331646346\n\nThere are 114125 words in The_Adventures_of_Huckleberry_Finn.\nThere are 14307 different words in The_Adventures_of_Huckleberry_Finn.\nThe unique word ratio is 0.12536254107338446\n\nThere are 464023 words in The_Count_of_Monte_Cristo.\nThere are 40030 different words in The_Count_of_Monte_Cristo.\nThe unique word ratio is 0.0862672755445312\n\nThere are 51257 words in The_Great_Gatsby.\nThere are 10206 different words in The_Great_Gatsby.\nThe unique word ratio is 0.19911426731958562\n```\n:::\n:::\n\n\n### Modularity *beyond the script*: modules\n\nWhat actually happens when you run `import ...`? Python adds the contents of *another* Python file to the existing 'namespace'. Basically, you *import* a bunch of functions (and classes, and other objects...)!\n\nWe can make our own modules that Python recognises with the `import` command. The simplest way is just another Python script. Let's make one to store our new function, so it's out of the way.\n\n1. Create a new script in this folder called `reader.py`\n2. Move the function into that file.\n\nThe script should look like this:\n\n**`reader.py`**\n\n::: {#cb309591 .cell execution_count=54}\n``` {.python .cell-code}\ndef read_book_words(path):  \n    with open(path, encoding = \"utf-8\") as file:\n        contents = file.read()\n    \n    return contents\n```\n:::\n\n\nFinally, we should reflect the changes in our original script.\n\n1. Replace the old function definition with the command `import reader`.\n2. Replace the old function `read_book_words(...)` with the command `reader.read_book_words(...)\n\nThe main script should look like this\n\n**`toolkit.py`**\n\n::: {#c887688e .cell execution_count=55}\n``` {.python .cell-code}\nimport os\nimport reader\n\nprint(\"Running the Python Toolkit Program\")\nprint(f\"The current working directory is {os.getcwd()}\")\n\n# Check that the folder exists in our working directory\nif os.path.exists(\"texts\"):\n    print(\"The folder /texts/ exists.\")\nelse:\n    raise FileNotFoundError(\"Cannot find the folder /texts/.\")\n\nfiles_in_texts = os.listdir(\"texts\")\n\n# Check that there are five files within texts\nif len(files_in_texts) != 5:\n    raise FileNotFoundError(\"Incorrect number of files in /texts/.\")\n\n#### Part 2 ####\nfiles_in_texts = os.listdir(\"texts\")\n\nfor text_path in files_in_texts:\n    title = text_path[:-4]\n\n    contents = reader.read_book(f\"texts/{text_path}\")\n    words = contents.split()\n\n    unique_words = set(words)\n\n    word_count = len(words)\n    unique_word_count = len(unique_words)\n    ratio = unique_word_count / word_count\n\n    print()\n    print(f\"There are {word_count} words in {title}.\")\n    print(f\"There are {unique_word_count} different words in {title}.\")\n    print(f\"The unique word ratio is {unique_word_count / word_count}\")\n\n    # Remove front/end matter and save clean files\n    start_message = \"*** START OF THE PROJECT GUTENBERG EBOOK\"\n    end_message = \"*** END OF THE PROJECT GUTENBERG EBOOK\"\n\n    start = contents.find(start_message)\n    end = contents.find(end_message)\n\n    clean_text = contents[start:end]\n\n    with open(f\"{title}_clean.txt\", \"w\", encoding = \"utf-8\") as file:\n        file.write(clean_text)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning the Python Toolkit Program\nThe current working directory is C:\\Users\\uqcwest5\\OneDrive - The University of Queensland\\Tech Training\\technology-training\\Python\\5-python_toolkit\nThe folder /texts/ exists.\n\nThere are 21428 words in Macbeth.\nThere are 6207 different words in Macbeth.\nThe unique word ratio is 0.2896677244726526\n\nThere are 130410 words in Pride_and_Prejudice.\nThere are 14702 different words in Pride_and_Prejudice.\nThe unique word ratio is 0.11273675331646346\n\nThere are 114125 words in The_Adventures_of_Huckleberry_Finn.\nThere are 14307 different words in The_Adventures_of_Huckleberry_Finn.\nThe unique word ratio is 0.12536254107338446\n\nThere are 464023 words in The_Count_of_Monte_Cristo.\nThere are 40030 different words in The_Count_of_Monte_Cristo.\nThe unique word ratio is 0.0862672755445312\n\nThere are 51257 words in The_Great_Gatsby.\nThere are 10206 different words in The_Great_Gatsby.\nThe unique word ratio is 0.19911426731958562\n```\n:::\n:::\n\n\n## Conclusion and Summary\n\nThis is a big workshop, and we've covered a lot of content! See the summary table below for details on the topics covered. Each is linked to the notes in the workshop.\n\n<!-- Resources ??? -->\nIf you have any further questions, don't hesistate to contact us at [training@library.uq.edu.au](mailto:training@library.uq.edu.au).\n\n<!-- \nTo make substantial changes to the table below, or write new ones, use \nhttps://www.tablesgenerator.com/text_tables \nwith \"Use reStructuredText syntax\" ticked\n\nAlternatively, see https://quarto.org/docs/authoring/tables.html#grid-tables\n-->\n+-------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Topic                               | Code                                  | Description                                                                                                                                                     |\n+=====================================+=======================================+=================================================================================================================================================================+\n| [The `os` module](#os)              | ```python                             | A built-in module which enables interacting with your operating system.                                                                                         |\n|                                     | import os                             |                                                                                                                                                                 |\n|                                     | os.getwd()                            |                                                                                                                                                                 |\n|                                     | os.chdir()                            |                                                                                                                                                                 |\n|                                     | os.listdir()                          |                                                                                                                                                                 |\n|                                     | ```                                   |                                                                                                                                                                 |\n+-------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| [f-strings](#fstrings)              | ```python                             | Formatted strings, which behave like normal strings except that code within curly brackets `{...}` is **executed**.                                             |\n|                                     | f\"1+1 = {1+1}\"                        |                                                                                                                                                                 |\n|                                     | ```                                   |                                                                                                                                                                 |\n+-------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| [Conditionals](#conditionals)       | <i>                                   | Sections of code which only run if a condition is true.                                                                                                         |\n|                                     | ```python                             |                                                                                                                                                                 |\n|                                     | if <condition1>:                      | Always start with `if`.                                                                                                                                         |\n|                                     |     ...                               |                                                                                                                                                                 |\n|                                     | elif <condition2>:                    | Use `elif` to check additional conditions (only if the first fail).                                                                                             |\n|                                     |     ....                              |                                                                                                                                                                 |\n|                                     | else:                                 | Use `else` to catch everything that fails all conditions.                                                                                                       |\n|                                     |     ....                              |                                                                                                                                                                 |\n|                                     | ```                                   |                                                                                                                                                                 |\n|                                     | </i>                                  |                                                                                                                                                                 |\n+-------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| [Raising exceptions](#raise)        | ```python                             | A way to manually trigger error messages and stop the program. Replace `...` with an errortype, e.g. `KeyError`, `ValueError`.                                  |\n|                                     | raise ...Error(\"error_message\")       |                                                                                                                                                                 |\n|                                     | ```                                   |                                                                                                                                                                 |\n+-------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| [File input/output](#file-io)       | <i>                                   | Read and write to files with the `open()` function and `with ... as ...` blocks.                                                                                |\n|                                     | ```python                             |                                                                                                                                                                 |\n|                                     | with open(...) as <placeholder>:      | Most files use the `utf-8` encoding, which *isn't* set by default.                                                                                              |\n|                                     |     ...                               |                                                                                                                                                                 |\n|                                     | ```                                   | Send the `\"w\"` parameter to write to a file, and leave it out to read.                                                                                          |\n|                                     | </i>                                  |                                                                                                                                                                 |\n|                                     |                                       |                                                                                                                                                                 |\n|                                     | ```python                             |                                                                                                                                                                 |\n|                                     | open(\"path\", encoding = \"utf-8\")      |                                                                                                                                                                 |\n|                                     | open(\"path\", \"w\",                     |                                                                                                                                                                 |\n|                                     |      encoding = \"utf-8\")              |                                                                                                                                                                 |\n|                                     | ```                                   |                                                                                                                                                                 |\n+-------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| [Loops](#loops)                     | <i>                                   | Run sections of code multiple times with a loop.                                                                                                                |\n|                                     | ```python                             |                                                                                                                                                                 |\n|                                     | for <placeholder> in <iterable>:      | `for` loops run once for each element in an iterable object (e.g. a list). Each iteration stores the current element in what you specify for *`<placeholder>`*. |\n|                                     |    ...                                |                                                                                                                                                                 |\n|                                     | ```                                   | `while` loops run until *`<condition>`* is `False`. If it never becomes `False`, the loop runs indefinitely, and will eventually crash your program.            |\n|                                     |                                       |                                                                                                                                                                 |\n|                                     | ```python                             |                                                                                                                                                                 |\n|                                     | while <condition>:                    |                                                                                                                                                                 |\n|                                     |    ...                                |                                                                                                                                                                 |\n|                                     | ```                                   |                                                                                                                                                                 |\n+-------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| [Indexing and slicing](#slicing)    | ```python                             | Access individual elements of a string or list by indexing and slicing with square brackets.                                                                    |\n|                                     | example_string[1:4]                   |                                                                                                                                                                 |\n|                                     | ```                                   |                                                                                                                                                                 |\n+-------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Custom functions                    | <i>                                   | Store sections of code away in functions to run them at a later point.                                                                                          |\n|                                     | ```python                             |                                                                                                                                                                 |\n| Custom modules                      | def function_name(input1, input2):    | 1. Write a function definition with `def ...` which contains the code                                                                                           |\n|                                     |    ...                                | 2. Call the function to use it with specific inputs                                                                                                             |\n|                                     |    return ...                         |                                                                                                                                                                 |\n|                                     |                                       | You can store the functions in a separate script and import that script as a module.                                                                            |\n|                                     | function_name(a, b)                   |                                                                                                                                                                 |\n|                                     | ```                                   |                                                                                                                                                                 |\n|                                     | </i>                                  |                                                                                                                                                                 |\n|                                     |                                       |                                                                                                                                                                 |\n|                                     | ```python                             |                                                                                                                                                                 |\n|                                     | import module                         |                                                                                                                                                                 |\n|                                     | ```                                   |                                                                                                                                                                 |\n+-------------------------------------+---------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------+\n\n",
    "supporting": [
      "python_toolkit_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}